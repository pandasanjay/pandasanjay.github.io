{"componentChunkName":"component---src-templates-blog-post-jsx","path":"/feature-toggles-ideas-and-uses/","result":{"data":{"markdownRemark":{"html":"<h4>Easier to use, easiest to forget! Tools needed for maintenance, but better than merge conflicts!</h4>\n<blockquote>\n<h3><em>A knife helps chop onions, but be careful â€“ it can cut your fingers.</em></h3>\n</blockquote>\n<p><img src=\"https://miro.medium.com/max/4667/1*oUy4K1iGMy5bkQcsLbMwgA.png\" alt=\"Feature Toggle â€” Worth taking risk!\"></p>\n<p>Feature toggles aren't a new concept. In traditional programming, we often use flags (maybe stored in a database and accessed via API) to show or hide features. Today, let's focus on how feature toggles work in modern frontend applications.</p>\n<p>Imagine this scenario: two teams (let's say up to five teams is manageable), each with five members, working on the <em>same codebase</em>. Each team has its own features to deliver. This setup naturally raises some questions about managing the code effectively.</p>\n<h2>The Challenge: Managing Code Across Teams</h2>\n<p>When multiple teams collaborate on one codebase, the first instinct is often to isolate work using feature branches. But this approach frequently leads to complications:</p>\n<ul>\n<li>\n<p><strong>The Long-Running Branch Problem:</strong> Keeping features in separate branches for weeks or months seems safe at first. However, the longer a branch lives apart from the main development line (<code class=\"language-text\">develop</code> or <code class=\"language-text\">main</code>), the higher the risk of complex and painful merges later. Welcome to \"merge hell.\"</p>\n</li>\n<li>\n<p><strong>The Daily Merge Dilemma:</strong> \"Can't we just merge <code class=\"language-text\">develop</code> into our feature branches daily?\" Sure, you <em>can</em>, but this adds daily overhead and doesn't solve the fundamental problem. If another team merges a large feature (touching, say, 200 files), your \"simple\" daily merge can suddenly become a complex, conflict-ridden task.</p>\n</li>\n<li>\n<p><strong>The Hidden Risks:</strong> Even if you meticulously resolve merge conflicts (often needing significant cross-team discussion), hidden dangers remain. Subtle interactions between the merged codebases can introduce unexpected bugs or break existing functionality in ways that aren't immediately obvious during the merge.</p>\n</li>\n</ul>\n<p>This cycle of complex merges and integration risks is frustrating and can drastically slow down your team's development velocity.</p>\n<h2>The Testing Hurdle with Branches</h2>\n<p>\"Okay, but can't automated End-to-End (E2E) tests catch these integration issues?\"</p>\n<p>That's a good point! E2E tests <em>can</em> help. However, when you merge large, long-lived branches, you often need to spend significant time fixing tests to align with all the new changes. Even if the E2E tests eventually pass, manual testers still face challenges. They need to understand and test new scenarios and interactions they weren't previously aware of, consuming valuable time and effort.</p>\n<h2>The Release Bottleneck with Branches</h2>\n<p>\"Why not just release the feature branch when the feature is ready?\"</p>\n<p>Sounds simple, right? You're finally ready to ship your hard work to production â€“ time to celebrate! ðŸ¥‚</p>\n<p>But then reality hits:</p>\n<ul>\n<li>\"Oh no! The backend API isn't ready yet. That will take a few more weeks.\"</li>\n<li>\"Oops! The third-party integration we depend on is delayed.\"</li>\n<li>\"Hold on! Business decided this feature needs to go out <em>after</em> another feature, which isn't ready. We need to wait three months.\"</li>\n</ul>\n<p>\"No worries,\" you might think, \"we're safe in our separate branch. We'll just wait.\"</p>\n<p>But we're supposed to be agile! Waiting isn't ideal. The team needs to move on to new features, repeating the whole branching and merging cycle. Meanwhile, who is maintaining that delayed feature branch, keeping it updated with <code class=\"language-text\">develop</code>?</p>\n<p>Fast forward two weeks or three months...</p>\n<p>\"Aha! The backend is finally ready! Let's merge the feature branch!\"</p>\n<p>A developer estimates, \"Give me a couple of hours to handle the merge.\"</p>\n<p>Business waits eagerly for the good news.</p>\n<p>... \"Oh no! Not again!\" ðŸ™„ The <code class=\"language-text\">develop</code> branch has accumulated many new changes. Merging the old feature branch now involves resolving numerous conflicts. Afterwards, <em>both</em> the original feature <em>and</em> the newly integrated changes need thorough testing across all aspects. The release is delayed again, maybe until tomorrow, maybe longer.</p>\n<p>Repeat this painful process for every delayed feature release.</p>\n<p>If you recognize this pain, let's dive into a potential solution.</p>\n<h2>Feature Toggles: The Sharp but Helpful Alternative</h2>\n<blockquote>\n<h3><em>Very sharp like a knife, but very helpful.</em></h3>\n</blockquote>\n<p>Let's revisit our scenario: multiple teams working on the same codebase, each delivering features. How can feature toggles help?</p>\n<p>Think of each new feature being protected by a flag (a simple <code class=\"language-text\">if</code> condition). These flags are typically stored in configuration files (like JSON) within your project.</p>\n<p><strong>Example:</strong> Team A is building <code class=\"language-text\">feature1</code>, and Team B is building <code class=\"language-text\">feature2</code>. Both teams commit their code (wrapped in feature toggles) directly to the main <code class=\"language-text\">develop</code> branch.</p>\n<ul>\n<li>When Team A builds the application for testing, their build configuration enables the <code class=\"language-text\">feature1</code> toggle and disables <code class=\"language-text\">feature2</code>. They only see and test their feature.</li>\n<li>Conversely, Team B's test build enables <code class=\"language-text\">feature2</code> and disables <code class=\"language-text\">feature1</code>.</li>\n</ul>\n<p>How cool is that?</p>\n<p>With this approach, you avoid long-running feature branches and stay continuously integrated with the main <code class=\"language-text\">develop</code> branch.</p>\n<h3>Building Confidence with Toggled Features</h3>\n<p>\"How can teams be confident their code works when the main branch contains multiple other teams' untested features?\"</p>\n<p>This is where disciplined testing, especially E2E testing, becomes crucial. Your automated test suite needs to be toggle-aware. When you commit changes, the CI/CD pipeline should run tests against different toggle combinations.</p>\n<h3>How \"Toggle-Aware\" Testing Works</h3>\n<p>The test suite runs multiple times with different configurations:</p>\n<ol>\n<li><strong>Build for Team A:</strong> <code class=\"language-text\">feature1</code> toggle ON, <code class=\"language-text\">feature2</code> toggle OFF. Run only the tests relevant to <code class=\"language-text\">feature1</code>.</li>\n<li><strong>Build for Team B:</strong> <code class=\"language-text\">feature1</code> toggle OFF, <code class=\"language-text\">feature2</code> toggle ON. Run only the tests relevant to <code class=\"language-text\">feature2</code>.</li>\n<li><strong>(Optional but Recommended) Full Build:</strong> All toggles ON (or relevant combinations). Run regression tests covering interactions.</li>\n</ol>\n<p>This ensures features work in isolation and don't break existing functionality when disabled.</p>\n<h3>Releasing Features to Production</h3>\n<p>When a feature (say, <code class=\"language-text\">feature1</code>) is fully tested and ready for release:</p>\n<ol>\n<li>Remove the <code class=\"language-text\">feature1</code> toggle flag from the configuration.</li>\n<li>Remove the corresponding <code class=\"language-text\">if (feature1Enabled)</code> checks from the codebase.</li>\n<li>Deploy the <code class=\"language-text\">develop</code> branch to production.</li>\n</ol>\n<p>If a feature faces delays (like waiting for the backend), just keep its toggle in place (and turned off in the production configuration). The code is merged, but the feature remains hidden from users.</p>\n<h2>Adopting the Feature Toggle Workflow</h2>\n<p>Life with feature toggles requires adopting some new processes:</p>\n<ol>\n<li><strong>No More Long-Running Feature Branches:</strong> Commit small, incremental changes directly to the main branch, wrapped in toggles.</li>\n<li><strong>Manage Toggle Configurations:</strong> Keep toggle settings organized, perhaps in separate files per environment or team for clarity during development.</li>\n<li><strong>Test Thoroughly:</strong> Implement robust unit, integration, and E2E tests that are toggle-aware. Test features both when toggled ON and OFF.</li>\n<li><strong>Automate Everything:</strong> Automate builds, testing with different toggle configurations, and deployments.</li>\n<li><strong>Clean Up Toggles:</strong> This is critical! Once a feature is fully released and stable, <em>remove the toggle</em> and the associated conditional logic from the codebase. Dead toggles add complexity.</li>\n<li><strong>Automate Toggle Removal:</strong> Use tools like codemods (e.g., <a href=\"https://github.com/facebook/jscodeshift\">jscodeshift</a>) to help automate the removal of toggle code once a feature is launched.</li>\n</ol>\n<p>With the right safety precautions and automation, feature toggles allow you to release features more confidently and frequently. All the best!</p>\n<hr>\n<p>What are your solutions to the multi-team, single-codebase challenge? Please share in the comments â€“ it might help others!</p>","excerpt":"Easier to use, easiest to forget! Tools needed for maintenance, but better than merge conflicts! A knife helps chop onions, but be careful â€“ it can cut yourâ€¦","fields":{"slug":"/feature-toggles-ideas-and-uses/"},"frontmatter":{"title":"Feature Toggles Ideas and Uses","date":"2019-01-20T00:00:00.000Z","tags":["Git","Toggles","Feature Toggles","CI CD Pipeline","Automation"]}}},"pageContext":{"slug":"/feature-toggles-ideas-and-uses/","previous":null,"next":null}},"staticQueryHashes":["2711202223","3159585216"],"slicesMap":{}}